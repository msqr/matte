/* ===================================================================
 * MediaAlbumConfigUtil.java
 * 
 * Copyright (c) 2002-2003 Matt Magoffin.
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation; either version 2 of 
 * the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License 
 * along with this program; if not, write to the Free Software 
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
 * 02111-1307 USA
 * ===================================================================
 * MediaAlbumConfigUtil.java,v 1.1 2002/10/07 19:50:08 mmagoffin Exp
 * ===================================================================
 */

package magoffin.matt.ma.util;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import magoffin.matt.ma.ApplicationConstants;
import magoffin.matt.ma.MediaAlbumException;
import magoffin.matt.ma.MediaRequestHandler;
import magoffin.matt.ma.xsd.InitParamConfig;
import magoffin.matt.ma.xsd.MediaAlbumConfig;
import magoffin.matt.ma.xsd.MediaHandlerConfig;
import magoffin.matt.ma.xsd.MediaServerConfig;
import magoffin.matt.ma.xsd.TableReference;
import magoffin.matt.util.config.Config;
import magoffin.matt.xsd.ObjectPoolConfig;

import org.apache.commons.pool.PoolableObjectFactory;
import org.apache.log4j.Logger;

/**
 * Static help methods for the MediaAlbumConfig object.
 * 
 * <p>Created Oct 7, 2002 10:03:08 AM.</p>
 * 
 * @author Matt Magoffin (spamsqr@msqr.us)
 */
public class MediaAlbumConfigUtil {
	
	private static final Logger log = Logger.getLogger(MediaAlbumConfigUtil.class);


/**
 * Generate a Map of MIME type to media handler instances.
 *
 * @param config the config to use
 * @return Map
 */
public static Map getMediaHandlerMap(MediaAlbumConfig appConfig, PoolFactory pf)
{
	MediaServerConfig config = appConfig.getMediaServer();
	if ( config == null || config.getMediaHandlerCount() < 1 ) {
		return new HashMap(0);
	}
	
	Map mediaRequestHandlerMap = new HashMap(config.getMediaHandlerCount());
	MediaHandlerConfig[] hConfigs = config.getMediaHandler();
	for ( int i = 0; i < hConfigs.length; i++ ) {
		try {
			Object o = Class.forName(hConfigs[i].getImpl()).newInstance();
			if ( o instanceof MediaRequestHandler ) {
				if ( log.isDebugEnabled() ) {
					log.debug("Initializing MediaRequestHandler for " +hConfigs[i].getMime());
				}
				MediaRequestHandler mrh = (MediaRequestHandler)o;
				mrh.init(hConfigs[i], pf, appConfig);
				mediaRequestHandlerMap.put(hConfigs[i].getMime(),mrh);
			} else {
				log.warn("Class not MediaRequestHandler: " +hConfigs[i].getImpl());
			}
		} catch ( Exception e) {
			log.error("Can't load MediaRequestHandler " +hConfigs[i].getImpl() +": " +e);
		}
	}
	return mediaRequestHandlerMap;
}


/**
 * Generate a Map of file extensions to media handler instances.
 * 
 * <p>The <var>mediaHandlerMap</var> Map is used to prevent any
 * extensions that are not configured properly to be added to the 
 * resulting Map (i.e. if a MediaHandler instance fails to be
 * created).</p>
 * 
 * @param config the config to use
 * @param mediaHandlerMap a Map of the same format as generated by 
 * {@link #getMediaHandlerMap(MediaAlbumConfig, PoolFactory)}
 * @return Map
 */
public static Map getMediaHandlerExtensionMap(
	MediaServerConfig config,
	Map mediaHandlerMap )
{
	if ( config == null || config.getMediaHandlerCount() < 1 ) {
		return new HashMap(0);
	}

	// create our filename filter and extnesion map
	MediaHandlerConfig[] handlers = config.getMediaHandler();
	Map mediaExtensionMap = new HashMap(handlers.length*2);
	for ( int i = 0; i < handlers.length; i++) {
		String[] extensions = handlers[i].getFilenameExtension();
		Object handler = mediaHandlerMap.get(handlers[i].getMime());
		if ( handler != null ) {
			for ( int j = 0; j < extensions.length; j++ ) {
				mediaExtensionMap.put(extensions[j].toLowerCase(),handler);
			}
		}
	}
	return mediaExtensionMap;
}


/**
 * Generate a Map of file extensions to MIME type.
 *
 * <p>The <var>mediaHandlerMap</var> Map is used to prevent any
 * extensions that are not configured properly to be added to the 
 * resulting Map (i.e. if a MediaHandler instance fails to be
 * created).</p>
 * 
 * @param  config the config to use
 * @param mediaHandlerMap a Map of the same format as generated by
 * {@link #getMediaHandlerMap(MediaAlbumConfig, PoolFactory)}
 * @return Map
 */
public static Map getMediaHandlerExtensionMimeMap(
	MediaServerConfig config,
	Map mediaHandlerMap )
{
	if ( config == null || config.getMediaHandlerCount() < 1 ) {
		return new HashMap(0);
	}

	// create our filename filter and extnesion map
	MediaHandlerConfig[] handlers = config.getMediaHandler();
	Map mediaExtensionMimeMap = new HashMap(handlers.length);
	for ( int i = 0; i < handlers.length; i++) {
		String[] extensions = handlers[i].getFilenameExtension();
		Object handler = mediaHandlerMap.get(handlers[i].getMime());
		if ( handler != null ) {
			for ( int j = 0; j < extensions.length; j++ ) {
				mediaExtensionMimeMap.put(extensions[j].toLowerCase(),handlers[i].getMime());
			}
		}
	}
	return mediaExtensionMimeMap;
}


/**
 * Generate a Map of MIME type to file extensions.
 *
 * <p>The <var>mediaHandlerMap</var> Map is used to prevent any
 * extensions that are not configured properly to be added to the
 * resulting Map (i.e. if a MediaHandler instance fails to be
 * created).</p>
 *
 * @param  config the config to use
 * @param mediaHandlerMap a Map of the same format as generated by
 * {@link #getMediaHandlerMap(MediaAlbumConfig, PoolFactory)}
 * @return Map
 */
public static Map getMediaHandlerMimeExtensionMap(
	MediaServerConfig config,
	Map mediaHandlerMap )
{
	if ( config == null || config.getMediaHandlerCount() < 1 ) {
		return new HashMap(0);
	}

	// create our filename filter and extnesion map
	MediaHandlerConfig[] handlers = config.getMediaHandler();
	Map mediaExtensionMimeMap = new HashMap(handlers.length);
	for ( int i = 0; i < handlers.length; i++) {
		String[] extensions = handlers[i].getFilenameExtension();
		Object handler = mediaHandlerMap.get(handlers[i].getMime());
		if ( handler != null ) {
			for ( int j = 0; j < extensions.length; j++ ) {
				mediaExtensionMimeMap.put(handlers[i].getMime(),extensions[j].toLowerCase());
			}
		}
	}
	return mediaExtensionMimeMap;
}

/**
 * Returns <em>true</em> if the file name is of a supported type.
 *
 * @param fileName the name of the file to test
 * @param extensionMap a Map, as returned by 
 * {@link #getMediaHandlerExtensionMap(MediaServerConfig, Map)}.</p>
 * 
 * @return boolean
 */
public static boolean isFileTypeSupported(String fileName, Map extensionMap) 
{
	int idx = fileName.lastIndexOf('.');
	if ( idx > 0  && (idx+1) < fileName.length() ) { // don't allow dot-file names
		String ext = fileName.substring(idx+1);
		if ( extensionMap.containsKey(ext.toLowerCase()) ) {
			return true;
		}
	}
	return false;
}


public static PoolFactory getPoolFactory(MediaAlbumConfig config)
{
	// get the media request pool
	ObjectPoolConfig mrPoolConfig = config.getMediaRequestPool();
	PoolFactory pf = new PoolFactory(mrPoolConfig);
	if ( log.isDebugEnabled() ) {
		log.debug("Initializing media request pool factory: " +pf);
	}
	
	InitParamConfig[] mrInit = config.getMediaRequestPoolImpl();
	for ( int i = 0; i < mrInit.length; i++ ) {
		if ( log.isDebugEnabled() ) {
			log.debug("Registering media request pool: " 
				+mrInit[i].getName()+", impl: " +mrInit[i].getContent());
		}
		try {
			Class c1 = Class.forName(mrInit[i].getName());
			PoolableObjectFactory pof = (PoolableObjectFactory)
				Class.forName(mrInit[i].getContent()).newInstance();
			pf.registerPoolableObjectFactory(c1,pof);
		} catch ( Exception e ) {
			log.warn("Unable to register media request pool for " +mrInit[i].getName()
				+": " +e.getMessage());
		}
	}
	
	return pf;
}

public static TableReference getTableReference(MediaAlbumConfig config, String key)
throws MediaAlbumException
{
	int count = config.getTableRefCount();
	if ( count < 1 ) {
		throw new MediaAlbumException("No table references defined in application config.");
	}
	for ( int i = 0; i < count; i++ ) {
		TableReference ref = config.getTableRef(i);
		if ( key.equals(ref.getKey()) ) {
			return ref;
		}
	}
	throw new MediaAlbumException("Table reference '" +key +"' not defined in application config.");
}

/**
 * Get the base WWW directory for the applicaiton.
 * @return the base WWW directory, or <em>null</em> if not available
 */
public static File getBaseWWWDir()
{
	String wwwBaseFilePath = Config.get(ApplicationConstants.CONFIG_ENV,
			ApplicationConstants.ENV_BASE_FILE_PATH_WWW);
	if ( wwwBaseFilePath == null ) {
		log.error("Required environment property '" 
			+ApplicationConstants.ENV_BASE_FILE_PATH_WWW 
			+"' not provided.");
		return null;
	}
	File f = new File(wwwBaseFilePath);
	if ( !f.exists() || !f.isDirectory() ) {
		log.error("WWW base dir '" +ApplicationConstants.ENV_BASE_FILE_PATH_WWW 
			+"' defined, but path not accessible: " +wwwBaseFilePath);
		return null;
	}
	return f;
}

} // class MediaAlbumConfigUtil
